// Generated by CoffeeScript 1.10.0
var adjacency_graphs, calc_average_degree, k, scoring, v;

adjacency_graphs = require('./adjacency_graphs');

calc_average_degree = function(graph) {
  var average, k, key, n, neighbors, v;
  average = 0;
  for (key in graph) {
    neighbors = graph[key];
    average += ((function() {
      var l, len, results;
      results = [];
      for (l = 0, len = neighbors.length; l < len; l++) {
        n = neighbors[l];
        if (n) {
          results.push(n);
        }
      }
      return results;
    })()).length;
  }
  average /= ((function() {
    var results;
    results = [];
    for (k in graph) {
      v = graph[k];
      results.push(k);
    }
    return results;
  })()).length;
  return average;
};

scoring = {
  nCk: function(n, k) {
    var d, l, r, ref;
    if (k > n) {
      return 0;
    }
    if (k === 0) {
      return 1;
    }
    r = 1;
    for (d = l = 1, ref = k; 1 <= ref ? l <= ref : l >= ref; d = 1 <= ref ? ++l : --l) {
      r *= n;
      r /= d;
      n -= 1;
    }
    return r;
  },
  lg: function(n) {
    return Math.log(n) / Math.log(2);
  },
  minimum_entropy_match_sequence: function(password, matches) {
    var backpointers, bruteforce_cardinality, candidate_entropy, crack_time, i, j, k, l, len, len1, m, make_bruteforce_match, match, match_sequence, match_sequence_copy, min_entropy, o, ref, ref1, ref2, up_to_k;
    bruteforce_cardinality = this.calc_bruteforce_cardinality(password);
    up_to_k = [];
    backpointers = [];
    for (k = l = 0, ref = password.length; 0 <= ref ? l < ref : l > ref; k = 0 <= ref ? ++l : --l) {
      up_to_k[k] = (up_to_k[k - 1] || 0) + this.lg(bruteforce_cardinality);
      backpointers[k] = null;
      for (m = 0, len = matches.length; m < len; m++) {
        match = matches[m];
        if (!(match.j === k)) {
          continue;
        }
        ref1 = [match.i, match.j], i = ref1[0], j = ref1[1];
        candidate_entropy = (up_to_k[i - 1] || 0) + this.calc_entropy(match);
        if (candidate_entropy < up_to_k[j]) {
          up_to_k[j] = candidate_entropy;
          backpointers[j] = match;
        }
      }
    }
    match_sequence = [];
    k = password.length - 1;
    while (k >= 0) {
      match = backpointers[k];
      if (match) {
        match_sequence.push(match);
        k = match.i - 1;
      } else {
        k -= 1;
      }
    }
    match_sequence.reverse();
    make_bruteforce_match = (function(_this) {
      return function(i, j) {
        return {
          pattern: 'bruteforce',
          i: i,
          j: j,
          token: password.slice(i, +j + 1 || 9e9),
          entropy: _this.lg(Math.pow(bruteforce_cardinality, j - i + 1)),
          cardinality: bruteforce_cardinality
        };
      };
    })(this);
    k = 0;
    match_sequence_copy = [];
    for (o = 0, len1 = match_sequence.length; o < len1; o++) {
      match = match_sequence[o];
      ref2 = [match.i, match.j], i = ref2[0], j = ref2[1];
      if (i - k > 0) {
        match_sequence_copy.push(make_bruteforce_match(k, i - 1));
      }
      k = j + 1;
      match_sequence_copy.push(match);
    }
    if (k < password.length) {
      match_sequence_copy.push(make_bruteforce_match(k, password.length - 1));
    }
    match_sequence = match_sequence_copy;
    min_entropy = up_to_k[password.length - 1] || 0;
    crack_time = this.entropy_to_crack_time(min_entropy);
    return {
      password: password,
      entropy: this.round_to_x_digits(min_entropy, 3),
      match_sequence: match_sequence,
      crack_time: this.round_to_x_digits(crack_time, 3),
      crack_time_display: this.display_time(crack_time),
      score: this.crack_time_to_score(crack_time)
    };
  },
  round_to_x_digits: function(n, x) {
    return Math.round(n * Math.pow(10, x)) / Math.pow(10, x);
  },
  SECONDS_PER_GUESS: .010 / 100,
  entropy_to_crack_time: function(entropy) {
    return .5 * Math.pow(2, entropy) * this.SECONDS_PER_GUESS;
  },
  crack_time_to_score: function(seconds) {
    if (seconds < Math.pow(10, 2)) {
      return 0;
    }
    if (seconds < Math.pow(10, 4)) {
      return 1;
    }
    if (seconds < Math.pow(10, 6)) {
      return 2;
    }
    if (seconds < Math.pow(10, 8)) {
      return 3;
    }
    return 4;
  },
  calc_entropy: function(match) {
    var entropy_functions;
    if (match.entropy != null) {
      return match.entropy;
    }
    entropy_functions = {
      dictionary: this.dictionary_entropy,
      spatial: this.spatial_entropy,
      repeat: this.repeat_entropy,
      sequence: this.sequence_entropy,
      regex: this.regex_entropy,
      date: this.date_entropy
    };
    return match.entropy = entropy_functions[match.pattern].call(this, match);
  },
  repeat_entropy: function(match) {
    var num_repeats;
    num_repeats = match.token.length / match.base_token.length;
    return match.base_entropy + this.lg(num_repeats);
  },
  sequence_entropy: function(match) {
    var base_entropy, first_chr;
    first_chr = match.token.charAt(0);
    if (first_chr === 'a' || first_chr === 'A' || first_chr === 'z' || first_chr === 'Z' || first_chr === '0' || first_chr === '1' || first_chr === '9') {
      base_entropy = 2;
    } else {
      if (first_chr.match(/\d/)) {
        base_entropy = this.lg(10);
      } else if (first_chr.match(/[a-z]/)) {
        base_entropy = this.lg(26);
      } else {
        base_entropy = this.lg(26) + 1;
      }
    }
    if (!match.ascending) {
      base_entropy += 1;
    }
    return base_entropy + this.lg(match.token.length);
  },
  MIN_YEAR_SPACE: 20,
  REFERENCE_YEAR: 2000,
  regex_entropy: function(match) {
    var char_class_bases, year_space;
    char_class_bases = {
      alpha_lower: 26,
      alpha_upper: 26,
      alpha: 52,
      alphanumeric: 62,
      digits: 10,
      symbols: 33
    };
    if (match.regex_name in char_class_bases) {
      return this.lg(Math.pow(char_class_bases[match.regex_name], match.token.length));
    } else {
      switch (match.regex_name) {
        case 'recent_year':
          year_space = Math.abs(parseInt(match.regex_match[0]) - this.REFERENCE_YEAR);
          year_space = Math.max(year_space, this.MIN_YEAR_SPACE);
          return this.lg(year_space);
      }
    }
  },
  date_entropy: function(match) {
    var entropy, year_space;
    year_space = Math.max(Math.abs(match.year - this.REFERENCE_YEAR), this.MIN_YEAR_SPACE);
    entropy = this.lg(year_space * 31 * 12);
    if (match.has_full_year) {
      entropy += 1;
    }
    if (match.separator) {
      entropy += 2;
    }
    return entropy;
  },
  KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty),
  KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad),
  KEYBOARD_STARTING_POSITIONS: ((function() {
    var ref, results;
    ref = adjacency_graphs.qwerty;
    results = [];
    for (k in ref) {
      v = ref[k];
      results.push(k);
    }
    return results;
  })()).length,
  KEYPAD_STARTING_POSITIONS: ((function() {
    var ref, results;
    ref = adjacency_graphs.keypad;
    results = [];
    for (k in ref) {
      v = ref[k];
      results.push(k);
    }
    return results;
  })()).length,
  spatial_entropy: function(match) {
    var L, S, U, d, entropy, i, j, l, m, o, possibilities, possible_turns, ref, ref1, ref2, ref3, s, t;
    if ((ref = match.graph) === 'qwerty' || ref === 'dvorak') {
      s = this.KEYBOARD_STARTING_POSITIONS;
      d = this.KEYBOARD_AVERAGE_DEGREE;
    } else {
      s = this.KEYPAD_STARTING_POSITIONS;
      d = this.KEYPAD_AVERAGE_DEGREE;
    }
    possibilities = 0;
    L = match.token.length;
    t = match.turns;
    for (i = l = 2, ref1 = L; 2 <= ref1 ? l <= ref1 : l >= ref1; i = 2 <= ref1 ? ++l : --l) {
      possible_turns = Math.min(t, i - 1);
      for (j = m = 1, ref2 = possible_turns; 1 <= ref2 ? m <= ref2 : m >= ref2; j = 1 <= ref2 ? ++m : --m) {
        possibilities += this.nCk(i - 1, j - 1) * s * Math.pow(d, j);
      }
    }
    entropy = this.lg(possibilities);
    if (match.shifted_count) {
      S = match.shifted_count;
      U = match.token.length - match.shifted_count;
      if (U === 0) {
        entropy += 1;
      } else {
        possibilities = 0;
        for (i = o = 1, ref3 = Math.min(S, U); 1 <= ref3 ? o <= ref3 : o >= ref3; i = 1 <= ref3 ? ++o : --o) {
          possibilities += this.nCk(S + U, i);
        }
        entropy += this.lg(possibilities);
      }
    }
    return entropy;
  },
  dictionary_entropy: function(match) {
    match.base_entropy = this.lg(match.rank);
    match.uppercase_entropy = this.extra_uppercase_entropy(match);
    match.reversed_entropy = match.reversed && 1 || 0;
    match.l33t_entropy = this.extra_l33t_entropy(match);
    return match.base_entropy + match.uppercase_entropy + match.l33t_entropy + match.reversed_entropy;
  },
  START_UPPER: /^[A-Z][^A-Z]+$/,
  END_UPPER: /^[^A-Z]+[A-Z]$/,
  ALL_UPPER: /^[^a-z]+$/,
  ALL_LOWER: /^[^A-Z]+$/,
  extra_uppercase_entropy: function(match) {
    var L, U, chr, i, l, len, m, possibilities, ref, ref1, regex, word;
    word = match.token;
    if (word.match(this.ALL_LOWER)) {
      return 0;
    }
    ref = [this.START_UPPER, this.END_UPPER, this.ALL_UPPER];
    for (l = 0, len = ref.length; l < len; l++) {
      regex = ref[l];
      if (word.match(regex)) {
        return 1;
      }
    }
    U = ((function() {
      var len1, m, ref1, results;
      ref1 = word.split('');
      results = [];
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        chr = ref1[m];
        if (chr.match(/[A-Z]/)) {
          results.push(chr);
        }
      }
      return results;
    })()).length;
    L = ((function() {
      var len1, m, ref1, results;
      ref1 = word.split('');
      results = [];
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        chr = ref1[m];
        if (chr.match(/[a-z]/)) {
          results.push(chr);
        }
      }
      return results;
    })()).length;
    possibilities = 0;
    for (i = m = 1, ref1 = Math.min(U, L); 1 <= ref1 ? m <= ref1 : m >= ref1; i = 1 <= ref1 ? ++m : --m) {
      possibilities += this.nCk(U + L, i);
    }
    return this.lg(possibilities);
  },
  extra_l33t_entropy: function(match) {
    var S, U, chr, chrs, extra_entropy, i, l, p, possibilities, ref, ref1, subbed, unsubbed;
    if (!match.l33t) {
      return 0;
    }
    extra_entropy = 0;
    ref = match.sub;
    for (subbed in ref) {
      unsubbed = ref[subbed];
      chrs = match.token.toLowerCase().split('');
      S = ((function() {
        var l, len, results;
        results = [];
        for (l = 0, len = chrs.length; l < len; l++) {
          chr = chrs[l];
          if (chr === subbed) {
            results.push(chr);
          }
        }
        return results;
      })()).length;
      U = ((function() {
        var l, len, results;
        results = [];
        for (l = 0, len = chrs.length; l < len; l++) {
          chr = chrs[l];
          if (chr === unsubbed) {
            results.push(chr);
          }
        }
        return results;
      })()).length;
      if (S === 0 || U === 0) {
        extra_entropy += 1;
      } else {
        p = Math.min(U, S);
        possibilities = 0;
        for (i = l = 1, ref1 = p; 1 <= ref1 ? l <= ref1 : l >= ref1; i = 1 <= ref1 ? ++l : --l) {
          possibilities += this.nCk(U + S, i);
        }
        extra_entropy += this.lg(possibilities);
      }
    }
    return extra_entropy;
  },
  calc_bruteforce_cardinality: function(password) {
    var c, chr, cp, digits, i, l, latin1_letters, latin1_symbols, len, len1, lower, m, max_cp, min_cp, ord, range, ref, ref1, ref2, symbols, unicode_codepoints, upper;
    ref = (function() {
      var l, results;
      results = [];
      for (i = l = 0; l < 6; i = ++l) {
        results.push(false);
      }
      return results;
    })(), lower = ref[0], upper = ref[1], digits = ref[2], symbols = ref[3], latin1_symbols = ref[4], latin1_letters = ref[5];
    unicode_codepoints = [];
    ref1 = password.split('');
    for (l = 0, len = ref1.length; l < len; l++) {
      chr = ref1[l];
      ord = chr.charCodeAt(0);
      if ((0x30 <= ord && ord <= 0x39)) {
        digits = true;
      } else if ((0x41 <= ord && ord <= 0x5a)) {
        upper = true;
      } else if ((0x61 <= ord && ord <= 0x7a)) {
        lower = true;
      } else if (ord <= 0x7f) {
        symbols = true;
      } else if ((0x80 <= ord && ord <= 0xBF)) {
        latin1_symbols = true;
      } else if ((0xC0 <= ord && ord <= 0xFF)) {
        latin1_letters = true;
      } else if (ord > 0xFF) {
        unicode_codepoints.push(ord);
      }
    }
    c = 0;
    if (digits) {
      c += 10;
    }
    if (upper) {
      c += 26;
    }
    if (lower) {
      c += 26;
    }
    if (symbols) {
      c += 33;
    }
    if (latin1_symbols) {
      c += 64;
    }
    if (latin1_letters) {
      c += 64;
    }
    if (unicode_codepoints.length) {
      min_cp = max_cp = unicode_codepoints[0];
      ref2 = unicode_codepoints.slice(1);
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        cp = ref2[m];
        if (cp < min_cp) {
          min_cp = cp;
        }
        if (cp > max_cp) {
          max_cp = cp;
        }
      }
      range = max_cp - min_cp + 1;
      if (range < 40) {
        range = 40;
      }
      if (range > 100) {
        range = 100;
      }
      c += range;
    }
    return c;
  },
  display_time: function(seconds) {
    var base, century, day, display_num, display_str, hour, minute, month, ref, year;
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    month = day * 31;
    year = month * 12;
    century = year * 100;
    ref = seconds < minute ? [seconds, seconds + " second"] : seconds < hour ? (base = Math.round(seconds / minute), [base, base + " minute"]) : seconds < day ? (base = Math.round(seconds / hour), [base, base + " hour"]) : seconds < month ? (base = Math.round(seconds / day), [base, base + " day"]) : seconds < year ? (base = Math.round(seconds / month), [base, base + " month"]) : seconds < century ? (base = Math.round(seconds / year), [base, base + " year"]) : [null, 'centuries'], display_num = ref[0], display_str = ref[1];
    if ((display_num != null) && display_num !== 1) {
      display_str += 's';
    }
    return display_str;
  }
};

module.exports = scoring;

//# sourceMappingURL=scoring.js.map
